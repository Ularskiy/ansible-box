# Пример структуры Ansible-проекта

Этот проект — моя личная шпаргалка. Он не запускается, а создан для того, чтобы всегда можно было вспомнить, как правильно и приянтно организовать роль Ansible.

<!-- ------------------- -->
## ansible.cfg

Файл конфигурации Ansible.  
Упрощает работу: не нужно каждый раз прописывать все флаги вручную.

**Без него:**
ansible-playbook -i inventory/production/hosts.ini -u ansible playbooks/site.yml

**С ним:**
ansible-playbook playbooks/site.yml

Пример содержимого в ansible-box/examples/example-ansible-project/ansible.cfg

---

<!-- ------------------- -->
## inventory/

Инвентарь — это список серверов, с которыми работает Ansible.  
Все примеры находятся в `ansible-box/examples/example-ansible-project/inventory/`.


### Вариант 1 — Простой: только IP-адреса

Конфигурационный файл: `ansible-box/examples/example-ansible-project/inventory/ip_only_hosts.ini`

**Где использовать:**
- Быстрая проверка
- Один SSH пользователь
- Минимум настройки

**Плюсы:**
- Просто и быстро
- Подходит для экспериментов

**Минусы:**
- Нет имён хостов
- Нельзя задать порты, ключи, переменные
- Не работает с host_vars


### Вариант 2 — Именованные хосты с параметрами (рекомендуется)

Конфигурационный файл: `ansible-box/examples/example-ansible-project/inventory/example_hosts.ini`

**Где использовать:**
- Любой рабочий проект
- Продакшн и staging окружения
- Где нужно гибко управлять доступом

**Плюсы:**
- Понятные имена хостов
- Поддержка `host_vars`
- Настраиваемый SSH (пользователь, порт, ключ)

**Минусы:**
- Чуть больше писать
- Требует понимания переменных Ansible


### Вариант 3 — YAML-инвентарь

Конфигурационный файл: `ansible-box/examples/example-ansible-project/inventory/example_hosts.yml`


**Где использовать:**
- Автоматизация, Terraform, AWS
- Генерация динамических инвентарей
- Когда нужно хранить переменные и структуру в одном месте

**Плюсы:**
- Чёткая вложенность
- Вся структура и переменные в одном месте
- Подходит для сложных окружений

**Минусы:**
- Чувствителен к отступам
- Сложнее читать глазами
- Не все инструменты поддерживают YAML инвентари напрямую


### Как создать и использовать инвентарь

1. Создать файл: `inventory/production/hosts.ini` или `example_hosts.ini`
2. Указать в `ansible.cfg`:
```ini
[defaults]
inventory = inventory/production/hosts.ini
```
3. Запуск:
```bash
ansible-playbook playbooks/site.yml
```

### Вывод

| Формат     | Когда использовать          |
|------------|-----------------------------|
| IP         | Только для тестов и отладки |
| INI+имена  | Основной рабочий вариант    |
| YAML       | Автоматизация и CI/CD       |

---

<!-- ------------------- -->
## group_vars/ и host_vars/

### Вариант 1 — Глобальные переменные (для всех хостов)

Конфигурационный файл: `ansible-box/examples/example-ansible-project/group_vars/all.yml`

**Где использовать:**
- Когда переменная одинакова для всех хостов (например, имя пользователя)
- Задание глобальных настроек (локаль, регион, общие ключи)

**Плюсы:**
- Просто и логично
- Один источник правды для всех
- Не нужно дублировать

**Минусы:**
- Нельзя задать уникальные настройки для группы или хоста

### Вариант 2 — Переменные для группы хостов

Конфигурационный файл: `ansible-box/examples/example-ansible-project/group_vars/web.yml`

**Где использовать:**
- Когда одна роль применяется к группе, и все хосты группы используют одинаковые параметры

**Плюсы:**
- Централизованное управление конфигурацией группы
- Хорошо сочетается с inventory-группами

**Минусы:**
- Нельзя настроить уникальные параметры для конкретного хоста

### Вариант 3 — Переменные для одного хоста

Конфигурационный файл: `ansible-box/examples/example-ansible-project/host_vars/web01.yml`

**Где использовать:**
- Когда конкретному серверу нужно задать отдельные параметры
- Применение уникальных параметров, портов, путей

**Плюсы:**
- Полный контроль над настройками хоста
- Работает автоматически, если имя совпадает с inventory

**Минусы:**
- Чем больше хостов — тем больше файлов
- Могут возникать конфликты при дублировании переменных

### Приоритет переменных в Ansible

При совпадении имён переменных, Ansible использует приоритет (от меньшего к большему):

1. `group_vars/all.yml`
2. `group_vars/<имя_группы>.yml`
3. `host_vars/<имя_хоста>.yml`
4. Переменные, переданные через `--extra-vars`

Это означает, что `host_vars` всегда побеждает `group_vars`.

### Как создать и использовать

```bash
mkdir group_vars host_vars
touch group_vars/all.yml
touch group_vars/web.yml
touch host_vars/web01.yml
```

Имена файлов должны совпадать с именами из `inventory`.


### Вывод

| Уровень переменных | Применение                         |
|--------------------|-------------------------------------|
| group_vars/all     | Глобальные настройки               |
| group_vars/<group> | Общие параметры для группы         |
| host_vars/<host>   | Уникальные значения для хоста      |

Все переменные загружаются автоматически. Главное — правильное имя файла и его местоположение.
Ansible определяет область применение не по содержанию файла, а по его имени. Он смотрит в inventory, название групп должны между собой совпадать.

---
 
<!-- ------------------- -->
## playbooks/

Плейбуки (`*.yml`) — это наборы задач или вызовы ролей, которые описывают, **что и где нужно сделать**.

Файлы находятся здесь: `ansible-box/examples/example-ansible-project/playbooks/`

### Как писать и использовать playbook

Каждый плейбук описывает **один логический процесс**: настройка ОС, деплой приложения, установка Docker и т.д.

Пример структуры файла:
```yaml
- name: Название задачи
  hosts: <группа_или_хост>
  become: true
  roles:
    - <имя_роли>
```

### Вариант 1 — Единый плейбук "site.yml"

Конфигурационный файл: `ansible-box/examples/example-ansible-project/playbooks/site.yml`

**Где использовать:**
- Начальная настройка серверов
- Автоматизация "с нуля"
- Один вызов = всё развернуто

**Плюсы:**
- Один плейбук для всего
- Удобно запускать

**Минусы:**
- Тяжело переиспользовать
- Плохо масштабируется при большом количестве ролей


### Вариант 2 — Плейбук для конкретного действия (деплой)

Конфигурационный файл: `ansible-box/examples/example-ansible-project/playbooks/deploy_app.yml`

**Где использовать:**
- Когда нужно разворачивать/обновлять приложение отдельно от всего остального
- При наличии CI/CD

**Плюсы:**
- Разделение ответственности
- Удобно тестировать по отдельности
- Подходит для автоматизации

**Минусы:**
- Нужно запускать вручную несколько playbook’ов, если не собрать всё в цепочку

### Вариант 3 — Playbook с tasks вместо ролей

```yaml
- name: Установка Docker вручную
  hosts: all
  become: true
  tasks:
    - name: Установка пакета docker.io
      apt:
        name: docker.io
        state: present
```

**Где использовать:**
- В маленьких одноразовых сценариях
- Когда не нужна роль и переменные

**Плюсы:**
- Просто
- Быстро проверить что-то

**Минусы:**
- Нельзя переиспользовать
- Всё в одном месте, без структуры

### Как использовать

1. Пишешь плейбук в `playbooks/`
2. Запускаешь:
```bash
ansible-playbook playbooks/site.yml
```
3. Убеждаешься, что переменные находятся в `group_vars/` или `host_vars/`


### Вывод

| Подход           | Когда использовать           |
|------------------|------------------------------|
| site.yml         | Общая настройка всех серверов |
| deploy_app.yml   | Отдельный деплой/обновление  |
| tasks без ролей  | Быстрые одноразовые действия |

В больших проектах рекомендуется **делить плейбуки по логике**, а роли — использовать повторно.


### Почему playbooks и роли нужно разделять по логике

#### 1. Что значит “делить плейбуки по логике”?

Это значит: **один плейбук — одна цель**.

Вместо того чтобы делать один огромный `site.yml`, который:
- настраивает сеть
- создаёт пользователей
- деплоит базу данных
- ставит приложение

Нужно разбить всё на отдельные сценарии:

```
playbooks/
├── site.yml              # вызывает все нижние
├── infra_setup.yml       # только сеть, users, ssh
├── db_deploy.yml         # только БД (PostgreSQL, Mongo)
├── app_deploy.yml        # только приложение
├── monitoring.yml        # только Prometheus, Grafana
```

**Преимущества:**
- Запуск только нужной части
- Удобно интегрировать в CI/CD
- Легче отлаживать и тестировать
- Повышается читаемость


#### 2. Что значит “роли — использовать повторно”?

Роль — это **переиспользуемый модуль**.  
Если ты написал один раз `roles/infra/example_role_infra`, ты можешь вызывать его:

- в `infra_setup.yml`
- в `site.yml`
- в любом другом проекте

```yaml
- name: Настроить сеть
  hosts: all
  roles:
    - infra/example_role_infra
```

Ты **не дублируешь логику**, просто используешь одну и ту же роль в нужном контексте.


###  В связке это работает так:

- **Playbook** = когда и что делать
- **Role** = как именно это делать


###  Аналогия (для понимания):

| Компонент | Сравнение                     |
|-----------|-------------------------------|
| Playbook  | Сценарий театра (что, когда)  |
| Role      | Актёры, декорации (исполнение) |


---

<!-- ------------------- -->
## roles/ — роли Ansible

Роль в Ansible — это **переиспользуемый логический блок**, содержащий задачи (`tasks`), переменные (`defaults`, `vars`), шаблоны (`templates`), файлы и обработчики (`handlers`).


### Зачем нужны роли?

- Делают проект модульным
- Упрощают поддержку и масштабирование
- Позволяют вызывать один и тот же код в разных playbook'ах
- Позволяют переиспользовать конфигурацию между проектами

### Структура одной роли

```
roles/example_role/
├── tasks/
│   └── main.yml          # основной файл с задачами (обязательно)
├── defaults/
│   └── main.yml          # переменные по умолчанию (самый низкий приоритет)
├── vars/
│   └── main.yml          # переменные, которые нельзя переопределить
├── templates/            # Jinja2 шаблоны (nginx.conf.j2 и др.)
├── files/                # просто файлы для копирования
├── handlers/
│   └── main.yml          # обработчики (например, рестарт службы)
├── meta/
│   └── main.yml          # зависимости роли, поддерживаемые платформы
├── tests/                # автотесты для роли (необязательно)
│   ├── test.yml
│   └── inventory
└── README.md             # описание, как использовать роль
```



### Что писать в каждой директории внутри роли ?

| Директория   | Назначение                                                         |
|--------------|---------------------------------------------------------------------|
| `tasks/`     | Основные действия. Обязательный файл `main.yml` — точка входа роли |
| `defaults/`  | Значения по умолчанию. Можно переопределить в `group_vars`         |
| `vars/`      | Жёсткие переменные. Переопределить нельзя                          |
| `templates/` | Jinja2-шаблоны конфигураций (например, `nginx.conf.j2`)            |
| `files/`     | Статические файлы. Копируются как есть (`.sh`, `.conf`, и т.п.)    |
| `handlers/`  | Обработчики для `notify:` (рестарт nginx, systemd и т.п.)          |
| `meta/`      | Зависимости от других ролей, поддерживаемые платформы              |
| `tests/`     | Минимальные плейбуки и inventory для тестов                        |


### Категории ролей в проекте

| Категория | Назначение                                                         |
|-----------|---------------------------------------------------------------------|
| `infra/`  | Инфраструктура: сеть, SSH, hostname, системные пакеты              |
| `deploy/` | Приложения: деплой Flask, установка nginx, Docker и прочее         |
| `shared/` | Общее: создание пользователей, локаль, timezone, apt-настройки     |

---

<!-- ------------------- -->
## templates/ и files/

templates/ — шаблоны Jinja2 с переменными: например, nginx.conf.j2

files/ — обычные файлы, которые копируются без изменений: например, sshd_config, .bashrc


### Что такое Jinja2 и зачем нужны templates/ и files/

Ansible использует шаблонизатор **Jinja2**, чтобы генерировать конфигурации и файлы **на основе переменных, условий, циклов и фильтров**.

###  templates/ — для файлов с переменными (Jinja2)

Содержит **динамические шаблоны**. Обычно имеют расширение `.j2`.  
Ansible подставляет в них переменные и логические конструкции.

**Пример файла: `templates/nginx.conf.j2`**

```jinja
server {
  listen {{ nginx_port }};
  server_name {{ nginx_hostname }};
  root {{ nginx_root }};
}
```

**Пример использования в playbook:**

```yaml
- name: Скопировать конфиг nginx
  template:
    src: nginx.conf.j2
    dest: /etc/nginx/nginx.conf
```

**Когда использовать:**
- Когда файл отличается для каждого хоста
- Когда используются переменные
- Когда нужна логика: `if`, `for`, `default`, `join`, `replace` и т.д.


###  files/ — для статичных файлов

Содержит **готовые, неизменяемые файлы**, которые копируются без обработки.

**Пример использования в playbook:**

```yaml
- name: Копировать .bashrc
  copy:
    src: bashrc
    dest: /home/ansible/.bashrc
```

**Когда использовать:**
- Когда файл одинаковый на всех серверах
- Когда он не содержит переменных
- Для скриптов, ssh-ключей, бинарников, статичных конфигов


###  Разница между templates и files

| Каталог      | Обрабатывается Jinja2 | Используется с модулем  | Когда использовать                               |
|--------------|-----------------------|-------------------------|--------------------------------------------------|
| `templates/` |   Да                  | `template`              | Для конфигов с переменными и условиями (Jinja2)  |
| `files/`     |   Нет                 | `copy`                  | Для обычных файлов, без шаблонов                 |


---

<!-- ------------------- -->
## library/ — кастомные модули Ansible

В эту директорию можно положить **собственные модули Ansible на Python**.

Ansible сначала ищет модули здесь, затем в стандартной библиотеке.

### Когда использовать `library/`?

- Нужен модуль, которого нет в Ansible
- Нужно управлять нестандартным API или оборудованием
- Хочешь писать логику сам (например, кастомный API-запрос)


### Пример структуры

```text
library/
└── custom_api_call.py
```

**Пример использования:**

```yaml
- name: Выполнить свой модуль
  custom_api_call:
    endpoint: "https://..."
    token: "{{ api_token }}"
```

---

<!-- ------------------- -->
## Назначение

Этот проект — шаблон.  
Он помогает не вспоминать по кусочкам структуру, а сразу начинать работу правильно.  
Каждый блок продуман и разделён. Это экономит время и позволяет правильно организовывать структуру. 

